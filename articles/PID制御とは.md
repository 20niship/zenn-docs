---
title: "PID制御とは"
emoji: ""
type: ""
topics: undefined
published: false
---

世の中のほとんどの家電製品やロボットは、「**フィードバック制御**」と呼ばれる制御方法が使われています。

簡単に説明すると、「センサーによって現在の数値（これを制御する）を読み取り、それを目標値と比較して、目標値に近づけるように制御すること」です。

そして、そのフィードバック制御のアルゴリズム（ここではセンサーからの値と目標値をもとに、制御量を算出するアルゴリズム）の一つに、「**PID制御**」というものがあります。  
  
* [1.PID制御とは](#1PID制御とは)  
   * [PIDまでの道のり1：オンオフ制御](#PIDまでの道のり1オンオフ制御)  
   * [PIDまでの道のり1：P制御](#PIDまでの道のり1P制御)  
   * [PIDまでの道のり1：PD制御](#PIDまでの道のり1PD制御)
* [2.P制御、I制御、D制御のそれぞれの特徴](#2P制御I制御D制御のそれぞれの特徴)
* [3.ゲインの調整方法](#3ゲインの調整方法)

### 1.PID制御とは

PID制御とはフィードバック制御の一種で、次の式で表されます。  
![f:id:pythonjacascript:20181029221112p:plain](/images/ppythonjacascript2018102920181029221112.png "f:id:pythonjacascript:20181029221112p:plain")  
（Wikipediaより）

**...！？**

はい、詳しく見ていきます。  
  
#### PIDまでの道のり1：オンオフ制御

フィードバック制御の中で一番簡単な制御方法は、「**オンオフ制御**」と呼ばれるものです。  
下の図で、車が左から右に走っているとします。そして、できるだけ緑の線に近いところを走ろうとしています。  
![f:id:pythonjacascript:20181029235748j:plain](/images/ppythonjacascript2018102920181029235748.jpg "f:id:pythonjacascript:20181029235748j:plain")  
そのとき、車の現在地が目標値（緑の線）よりも上にいればハンドルを下に傾け（進行方向を下に変更）、目標値よりも下にいれば上に移動する、という制御です。赤の矢印の方向が制御出力を表しています。

こんな雑な制御でも、現在の計測値をもとに制御量（赤矢印の向き）を決定しているので、フィーバック制御ということができます。

**結果：**  
しかし、この制御には問題があります。この制御で車を走らせると、下の写真のように車の位置が一向に**安定せず、振動**する（**ハンチング**）のです。  
![f:id:pythonjacascript:20181030001246j:plain](/images/ppythonjacascript2018103020181030001246.jpg "f:id:pythonjacascript:20181030001246j:plain")  
これでは、安定した制御ができているということはできません。  
  
  
#### PIDまでの道のり1：P制御

**オンオフ制御**では、ハンドルの傾き（＝制御量の大きさ）が一定だった結果、振動してしまいました。  
しかし、下の図のように、**制御量を目標値と現在地の誤差に比例**させたらどうだろう、という感じで生まれたのが**P制御**です。PID制御の「P」は「P制御」を表しています。  
![f:id:pythonjacascript:20181030002116j:plain](/images/ppythonjacascript2018103020181030002116.jpg "f:id:pythonjacascript:20181030002116j:plain")

このように、現在地が目標地点から大きく離れているときは、大きく動かし（制御量を大きくして）、逆に目標地点と現在地がほとんど同じときは、あまり動かさない（制御量を小さくする）という制御です。

![ e_{(t)} = ](https://chart.apis.google.com/chart?cht=tx&chl=%20e_%7B%28t%29%7D%20%3D%20) (現在値) - (目標値）  
とすると、P制御は出力angleを  
![ angle = K_p \times e(t)](https://chart.apis.google.com/chart?cht=tx&chl=%20angle%20%3D%20K_p%20%5Ctimes%20e%28t%29)  
のように制御することです。上の式での ![ K_p](https://chart.apis.google.com/chart?cht=tx&chl=%20K_p) はP制御の感度（比例定数）を表しており、誤差の大きさに対して、どれほど出力を大きく変更するかを表しています。この値を変えることでP制御の強さを変えることができます。

  
**結果：**  
だがしかし、P制御でもまだ振動が起こります。  
![f:id:pythonjacascript:20181030004048j:plain](/images/ppythonjacascript2018103020181030004048.jpg "f:id:pythonjacascript:20181030004048j:plain")

理由は単純で、一言で言うならば、「**P制御 → ![F＝-Kx](https://chart.apis.google.com/chart?cht=tx&chl=F%EF%BC%9D-Kx) → 単振動！**」です。  
要は、ただ誤差に比例して制御量を決めているだけでは振動してしまう、ということになります。  
  
  
#### PIDまでの道のり1：PD制御

そこで、**振動を抑えるための制御**、「**D制御**」を導入しましょう～！

D制御を使うと、P制御の振動を抑えることができます。

その方法は、ズバリ「誤差の時間微分」です。言い換えると、P制御は「誤差そのもの」をもとにして制御していましたが、D制御は「誤差の変化量」に注目して制御する方法です。

「誤差」はP制御では「制御量」に比例していたため、「誤差の変化量」は「制御量の変化量」、つまり「どれだけ速く制御量（出力）を変化させているか」を表すこととなります。そして、出力変化が大きくなりすぎないように調整するのがDゲインです。

例えば、  
  
  
### 2.P制御、I制御、D制御のそれぞれの特徴

### 3.ゲインの調整方法