---
title: "【PIC】周波数カウンタの製作（測定編）"
emoji: ""
type: ""
topics: []
published: false
---

周波数カウンタとは、入力されたパルスの周波数を数える電子機器です。

今回は、周波数カウンタを**PIC16F688**を使って製作してみました。

* [周波数測定部](#周波数測定部)
* [データ送信部](#データ送信部)  
   * [レジスタの送信方法](#レジスタの送信方法)
* [ハードウェアについて](#ハードウェアについて)
* [測定部フローチャート](#測定部フローチャート)
* [サンプルプログラム](#サンプルプログラム)

### 周波数測定部

周波数を測定するには、PICの「**タイマー0**」の機能を使います。タイマー0には**T0CK1ピン**から入ってきたパルスを数えることができます。  
![f:id:pythonjacascript:20181202155856j:plain](/images/ppythonjacascript2018120220181202155856.jpg "f:id:pythonjacascript:20181202155856j:plain")  
(PIC16F688のデータシートより）

測定されるパルスは、上図の赤線の経路をたどってTMR0レジスタに蓄積されます。  
このようにして、タイマー0を**T0CK1ピン**を使って使用する場合、次のような設定が必要です。

| 設定        | 理由                                             |
| --------- | ---------------------------------------------- |
| T0SEビット＝1 | パルスが立ち上がった（「0」から「1」になった）時にTMR0レジスタをインクリメントするため |
| PSAビット＝1  | プリスケーラを使わない設定にする。測定したい周波数地によってプリスケーラを設定するべき    |
| T0CSビットを1 | タイマー0の入力クロックはT0CK1ピンから入力するため                   |

以上の3つの設定を行うことで、タイマー0のパルスの回数を測定することができます。このようにして、一秒間TMR0でパルスをカウントし、その値を測定した周波数とします。  
しかし、それでは0～254Hz（2の8乗）までしか計測できません。TMR0レジスタは8ビットのレジスタで、255個目のパルスが入力されえるとレジスタがオーバーフローするからです。

そこで、**OVERFLG**という変数を新しく作り、TMR0レジストがオーバーフローしたら、その時は、変数のOVERFLGをインクリメントします。TMR0レジスタがオーバーフローしたかどうかは**T0IF**ビットが1か同課で判断します。  
![f:id:pythonjacascript:20181202155419j:plain](/images/ppythonjacascript2018120220181202155419.jpg "f:id:pythonjacascript:20181202155419j:plain")

こうすることで、**0Hz～65535Hz**（2の16乗）の周波数を計測することができます。詳細なプログラムは下に載せています。  
  
  
### データ送信部

上の要領で測定した周波数のデータは、独自にプログラムしたシリアル通信アルゴリズムによって送信するアルゴリズムです。

まず、シリアル通信とは、データ（今回の場合は周波数）を１ビット（バイト）ずつ送信する方法のことです。PICには**EUSART**というシリアル通信の機能がついているが、これを使っても一度に９ビット（0～512）までの数字しか送れないので、シリアル通信のプログラムも自作した。

データを送信するピンは**TX\_PIN**（プログラム参照）で行います。  
送信順番は、

1. スタートビット（ON）を1ｍｓ
2. 変数OVERFLGを送信
3. TMR0レジスタを送信

の3ステップです。  
![f:id:pythonjacascript:20181202163537j:plain](/images/ppythonjacascript2018120220181202163537.jpg "f:id:pythonjacascript:20181202163537j:plain")

  
送信された信号を**ハンディーオシロ**（無料のオシロスコープアプリ）を使って可視化してみました。  
![f:id:pythonjacascript:20181202165006j:plain](/images/ppythonjacascript2018120220181202165006.jpg "f:id:pythonjacascript:20181202165006j:plain")

ちなみに、ハンディーオシロの使い方は、こちら↓  
[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/08/08/012956)

#### レジスタの送信方法

レジスタに格納されている8ビットの数値を送信するために、このようなアルゴリズムを組みました。

信号線1本でシリアル通信を行っているので、8ビットのデータを1ビットごとに分裂させて、それらを1つずつ送信する必要があります。  
![f:id:pythonjacascript:20181202163642j:plain](/images/ppythonjacascript2018120220181202163642.jpg "f:id:pythonjacascript:20181202163642j:plain")

そのため、上の図のように「右シフト」命令を利用しました。

1. 右シフトを行うと、レジスタの再開ビットの値がキャリーフラグに保存されます。
2. キャリーフラグの値を送信します。これでデータを1ビット分送信したことになります。

という操作を8回繰り返すと、一つのレジスタの値を送信することができます。  
  
  
### ハードウェアについて

下のプログラムを動かすための回路について簡単に説明します。  
下のプログラムは、**T0CK1ピン**からの入力パルスの周波数を測定するものなので、測定したい周波数はT0CK1ピンに入力してください。  
また、データのシリアル送信はTX\_PIN（プログラム参照）で行われます。デフォルトはPORTCの5ピンです。  
MCLRリセットを使用しているので、MCLRピンはプルアップしてください。  
  
### 測定部フローチャート

以上をもとに、このようなフローチャートで動作するプログラムを書きます。  
![f:id:pythonjacascript:20181202165510j:plain](/images/ppythonjacascript2018120220181202165510.jpg "f:id:pythonjacascript:20181202165510j:plain")  
このように、測定部と、送信部の2つの制御で成り立っていることがわかります。  
  
  
### サンプルプログラム

周波数カウンタの測定部プログラムです。マイコンは**PIC16F688**を使用します。

周波数カウンタというだけに、時間にシビアな動作が要求されるため、プログラムはアセンブリです。

;/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* ; Frequency Counter (PIC16F688) ;\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* LIST P=PIC16F688 INCLUDE "P16F688.INC" \_\_CONFIG \_FCMEN\_ON & \_IESO\_OFF & \_BOR\_ON & \_CP\_OFF & \_MCLRE\_ON & \_PWRTE\_ON & \_WDT\_OFF & \_INTOSCIO ;/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* ; 変数 ;\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/ GATEDATA EQU 20H ；周波数を格納する最下位バイト OVERFLG EQU 21H ；周波数を格納する最上位バイト CNT1 EQU 23H CNT2 EQU 24H CNT3 EQU 25H CNT4 EQU 28H TX\_CNT EQU 26H TEMP EQU 27H ；TX\_BITEで送信するデータを入れるバイト #DEFINE TX\_PIN PORTC,5 ；データ送信ピン ORG 0 MAIN CALL IOPORT CLRF OVERFLG CLRF GATEDATA MAINLOOP GOTO GET\_DATA\_L IOPORT CLRF PORTA CLRF PORTC MOVLW 07H MOVWF CMCON0 BSF STATUS,5 MOVLW 75H MOVWF OSCCON CLRF ANSEL MOVLW 0CH MOVWF TRISA CLRF TRISC BCF STATUS,RP0 CLRF TMR0 BCF INTCON,T0IF RETURN ;